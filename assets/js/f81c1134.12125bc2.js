"use strict";(globalThis.webpackChunkmez_docs=globalThis.webpackChunkmez_docs||[]).push([[130],{7735:n=>{n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"mez-2025-code-week-1","metadata":{"permalink":"/blog/mez-2025-code-week-1","editUrl":"https://github.com/Ashp116/MEZ_Docs/edit/main/blog/2025-11-06-instructional-code-wk1/index.mdx","source":"@site/blog/2025-11-06-instructional-code-wk1/index.mdx","title":"MEZ Instructional Code Week 1","description":"This tutorial introduces FRC robot programming fundamentals using a complete MaxSwerve drivetrain and coral manipulation system. You\'ll learn how subsystems, commands, and constants work together, then practice modifying motor speeds to see real-world effects on robot performance.","date":"2025-11-06T00:00:00.000Z","tags":[{"inline":false,"label":"Tutorial","permalink":"/blog/tags/tutorial","description":"Educational tutorials and guides"},{"inline":false,"label":"FRC","permalink":"/blog/tags/frc","description":"FIRST Robotics Competition related content"},{"inline":false,"label":"Java","permalink":"/blog/tags/java","description":"Java programming language content"},{"inline":false,"label":"Programming","permalink":"/blog/tags/programming","description":"Programming and software development content"}],"readingTime":7.28,"hasTruncateMarker":true,"authors":[{"name":"Ashp116","title":"MEZ Mentor","page":{"permalink":"/blog/authors/ashp-116"},"socials":{"github":"https://github.com/ashp116"},"imageURL":"https://github.com/ashp116.png","key":"ashp116"},{"name":"Noah Tonn","title":"MEZ Mentor","socials":{"github":"https://github.com/noahtonn"},"imageURL":"https://github.com/noahtonn.png","key":"noahtonn","page":null}],"frontMatter":{"slug":"mez-2025-code-week-1","title":"MEZ Instructional Code Week 1","authors":["ashp116","noahtonn"],"tags":["tutorial","frc","java","programming"]},"unlisted":false},"content":"This tutorial introduces FRC robot programming fundamentals using a complete MaxSwerve drivetrain and coral manipulation system. You\'ll learn how subsystems, commands, and constants work together, then practice modifying motor speeds to see real-world effects on robot performance.\\r\\n\\r\\n{/* truncate */}\\r\\n\\r\\n## Project Structure\\r\\n\\r\\nThis is a WPILib-based FRC robot project using Java for the 2024/2025 season. The robot is designed for coral manipulation (intake and shooting) with a sophisticated swerve drive system.\\r\\n\\r\\n```\\r\\nsrc/main/java/frc/robot/\\r\\n\u251c\u2500\u2500 Main.java\\r\\n\u251c\u2500\u2500 Robot.java\\r\\n\u251c\u2500\u2500 RobotContainer.java\\r\\n\u251c\u2500\u2500 Constants.java\\r\\n\u251c\u2500\u2500 subsystems/\\r\\n\u2502   \u251c\u2500\u2500 DriveTrainSubsystem.java\\r\\n\u2502   \u2514\u2500\u2500 IndexSubsystem.java\\r\\n\u2514\u2500\u2500 commands/\\r\\n    \u251c\u2500\u2500 DriveTrainCommand.java\\r\\n    \u251c\u2500\u2500 IntakeCommand.java\\r\\n    \u2514\u2500\u2500 ShootCommand.java\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## Subsystems\\r\\n\\r\\nSubsystems contain the interface for directly interacting with motors. They have \\"ownership\\" of the motors and the methods with which to move them.\\r\\n\\r\\n### IndexSubsystem\\r\\n\\r\\nIndexSubsystem owns the two index motors and the CANRange (distance sensor), declared in lines 11-13. IndexSubsystem provides methods to run the motors at intake and shoot speeds, as well as to stop the motors, all stated in lines 19-31.\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Subsystem\\\\IndexSubsystem\\"\\r\\npublic class IndexSubsystem extends SubsystemBase {\\r\\n    // Hardware declarations (lines 11-13)\\r\\n    private final CANSparkMax intakeMotor1;\\r\\n    private final CANSparkMax intakeMotor2;\\r\\n    private final DigitalInput coralSensor;\\r\\n    \\r\\n    // Motor control methods (lines 19-31)\\r\\n    public void runIntake() {\\r\\n        intakeMotor1.set(IntakeConstants.INTAKE_SPEED);\\r\\n        intakeMotor2.set(IntakeConstants.INTAKE_SPEED);\\r\\n    }\\r\\n    \\r\\n    public void runShoot() {\\r\\n        intakeMotor1.set(IntakeConstants.SHOOT_SPEED);\\r\\n        intakeMotor2.set(IntakeConstants.SHOOT_SPEED);\\r\\n    }\\r\\n    \\r\\n    public void stop() {\\r\\n        intakeMotor1.stopMotor();\\r\\n        intakeMotor2.stopMotor();\\r\\n    }\\r\\n    \\r\\n    public boolean hasGamePiece() {\\r\\n        return !coralSensor.get();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### DriveTrainSubsystem\\r\\n\\r\\nDriveSubsystem is responsible for the eight drivetrain motors, four drive and four turn. We will not go into details on this subsystem, but understand that it provides the interface and mathematics behind the swerve drive.\\r\\n\\r\\nThe subsystem includes:\\r\\n- 4-module swerve drive using REV MAXSwerve modules\\r\\n- NavX gyroscope integration for field-relative driving\\r\\n- Odometry and pose estimation for autonomous navigation\\r\\n- Advanced features like wheel locking (X-formation) and speed limiting\\r\\n\\r\\n---\\r\\n\\r\\n## Commands\\r\\n\\r\\nCommands allow users or predefined scripts to call their subsystems\' methods. They often reserve a subsystem, meaning only they can use it, then use a user\'s inputs or a predefined, timed script to call upon the subsystem, eventually affecting the robot.\\r\\n\\r\\nCommands run within an execution loop. When a command is first scheduled, its `initialize` method executes once. During each cycle of the loop, the `execute` method runs repeatedly. The command continues running until it is either interrupted externally (for example, when a button is released) or its `isFinished` method returns true, at which point the `end` method is called and the loop stops executing the command.\\r\\n\\r\\n### Command Lifecycle\\r\\n\\r\\n1. **initialize()** - Called once when the command starts\\r\\n2. **execute()** - Called repeatedly while the command is running\\r\\n3. **isFinished()** - Returns true when the command should end\\r\\n4. **end()** - Called once when the command finishes\\r\\n\\r\\n### IntakeCommand\\r\\n\\r\\nIntakeCommand requires IndexSubsystem, meaning that while it is running, no other command may operate on IndexSubsystem (lines 15-18). While it is running, it tells IndexSubsystem to run the index motors at intake speed (lines 23-26). IntakeCommand ends either when it stops being scheduled, because the user input stops, or because there is a game piece present in the intake as defined in the isFinished logic (lines 33-36). When IntakeCommand finishes, it calls IndexSubsystem to stop the motors\' movement (lines 28-31).\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Commands\\\\IntakeCommand.java\\"\\r\\npublic class IntakeCommand extends CommandBase {\\r\\n    private final IndexSubsystem indexSubsystem;\\r\\n    \\r\\n    public IntakeCommand(IndexSubsystem indexSubsystem) {\\r\\n        this.indexSubsystem = indexSubsystem;\\r\\n        addRequirements(indexSubsystem); // Lines 15-18: Reserve subsystem\\r\\n    }\\r\\n    \\r\\n    @Override\\r\\n    public void initialize() {\\r\\n        // Lines 23-26: Start intake motors\\r\\n        indexSubsystem.runIntake();\\r\\n    }\\r\\n    \\r\\n    @Override\\r\\n    public boolean isFinished() {\\r\\n        // Lines 33-36: End when game piece detected\\r\\n        return indexSubsystem.hasGamePiece();\\r\\n    }\\r\\n    \\r\\n    @Override\\r\\n    public void end(boolean interrupted) {\\r\\n        // Lines 28-31: Stop motors when finished\\r\\n        indexSubsystem.stop();\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### ShootCommand\\r\\n\\r\\nShootCommand requires IndexSubsystem, meaning that while it is running, no other command may operate on IndexSubsystem (lines 14-17). While it is running, it tells IndexSubsystem to run the index motors at shoot speed (lines 22-25). ShootCommand ends when user input stops. When ShootCommand finishes, it calls IndexSubsystem to stop the motors\' movement (lines 27-30).\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Commands\\\\ShootCommand.java\\"\\r\\npublic class ShootCommand extends CommandBase {\\r\\n    private final IndexSubsystem indexSubsystem;\\r\\n    \\r\\n    public ShootCommand(IndexSubsystem indexSubsystem) {\\r\\n        this.indexSubsystem = indexSubsystem;\\r\\n        addRequirements(indexSubsystem); // Lines 14-17: Reserve subsystem\\r\\n    }\\r\\n    \\r\\n    @Override\\r\\n    public void initialize() {\\r\\n        // Lines 22-25: Start shoot motors\\r\\n        indexSubsystem.runShoot();\\r\\n    }\\r\\n    \\r\\n    @Override\\r\\n    public void end(boolean interrupted) {\\r\\n        // Lines 27-30: Stop motors when finished\\r\\n        indexSubsystem.stop();\\r\\n    }\\r\\n    \\r\\n    // Command runs until button is released (no isFinished override)\\r\\n}\\r\\n```\\r\\n\\r\\n### DriveTrainCommand\\r\\n\\r\\nDriveTrainCommand contains the execute loop for driving and several additional methods for input smoothing. We will not be going into detail on this.\\r\\n\\r\\nThe command handles:\\r\\n- Field-relative driving with alliance color compensation\\r\\n- Advanced deadband system with static friction compensation\\r\\n- Power scaling (slow mode) via right trigger\\r\\n- Separate handling for linear and rotational movements\\r\\n\\r\\n---\\r\\n\\r\\n## Other Files\\r\\n\\r\\nFiles like Robot, RobotContainer, Constants, and other Util files may be present. Our format includes just the first three and a Main.\\r\\n\\r\\n### Main\\r\\n\\r\\nMain.java is used simply as a build target for Java. It does nothing but call the RobotBase static class and start an instance of Robot. Do not worry about the details of this file.\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Main.java\\" showLineNumbers=9\\r\\npublic final class Main {\\r\\n    private Main() {}\\r\\n\\r\\n    public static void main(String... args) {\\r\\n        RobotBase.startRobot(Robot::new);\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n### Robot\\r\\n\\r\\nRobot.java owns the RobotContainer class. It also handles scheduling by OP mode, or rather, commands that should be run continuously throughout the teleoperated, autonomous, test, or all OP modes.\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Robot.java\\" showLineNumbers=11\\r\\npublic class Robot extends TimedRobot {\\r\\n    private RobotContainer robotContainer;\\r\\n    \\r\\n    @Override\\r\\n    public void robotInit() {\\r\\n        robotContainer = new RobotContainer();\\r\\n    }\\r\\n    \\r\\n    @Override\\r\\n    public void teleopPeriodic() {\\r\\n        CommandScheduler.getInstance().run();\\r\\n    }\\r\\n    \\r\\n    // Additional OP mode methods...\\r\\n}\\r\\n```\\r\\n\\r\\n### RobotContainer\\r\\n\\r\\nRobotContainer.java owns all controllers, subsystems, and commands (lines 17-24). It also assigns controller inputs to commands (lines 30-33).\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\RobotContainer.java\\" showLineNumbers=16\\r\\npublic class RobotContainer {\\r\\n    // Controllers (lines 17-24)\\r\\n    private final XboxController driverController = new XboxController(0);\\r\\n    private final XboxController operatorController = new XboxController(1);\\r\\n    \\r\\n    // Subsystems\\r\\n    private final DriveTrainSubsystem driveTrainSubsystem = new DriveTrainSubsystem();\\r\\n    private final IndexSubsystem indexSubsystem = new IndexSubsystem();\\r\\n    \\r\\n    // Commands\\r\\n    private final IntakeCommand intakeCommand = new IntakeCommand(indexSubsystem);\\r\\n    private final ShootCommand shootCommand = new ShootCommand(indexSubsystem);\\r\\n    \\r\\n    public RobotContainer() {\\r\\n        configureButtonBindings();\\r\\n    }\\r\\n    \\r\\n    private void configureButtonBindings() {\\r\\n        // Lines 30-33: Assign inputs to commands\\r\\n        new Trigger(() -> operatorController.getLeftTriggerAxis() > 0.1)\\r\\n            .whileTrue(intakeCommand);\\r\\n        new Trigger(() -> operatorController.getRightTriggerAxis() > 0.1)\\r\\n            .whileTrue(shootCommand);\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n**Current Control Scheme:**\\r\\n- **Driver**: Left stick (translation), right stick (rotation), right trigger (slow mode)\\r\\n- **Operator**: Left trigger (intake), right trigger (shoot)\\r\\n\\r\\n### Constants\\r\\n\\r\\nConstants.java contains non-changing details about a robot\'s characteristics and how it should run. We have broken up our larger constants class into smaller classes broken up by subsystem/intent. Please see this file for examples.\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Constants.java\\"\\r\\npublic final class Constants {\\r\\n    public static final class DeviceConstants {\\r\\n        public static final int DRIVER_CONTROLLER_PORT = 0;\\r\\n        public static final int OPERATOR_CONTROLLER_PORT = 1;\\r\\n        public static final int INTAKE_MOTOR_TWO = 2;\\r\\n        public static final int DRIVER_CONTROLLER = 0;\\r\\n        public static final int ELEVATOR_MOTOR = 3;\\r\\n        // CAN IDs and other device constants\\r\\n    }\\r\\n    \\r\\n    public static final class IntakeConstants {\\r\\n        public static final double INTAKE_SPEED = 0.5;\\r\\n        public static final double SHOOT_SPEED = 0.8;\\r\\n        public static final double CORAL_DETECTION_DISTANCE = 5.0; // inches\\r\\n    }\\r\\n    \\r\\n    public static final class DriveConstants {\\r\\n        public static final double WHEEL_BASE = 24.0; // inches\\r\\n        public static final double TRACK_WIDTH = 24.0; // inches\\r\\n        // Swerve drive kinematics and module constants\\r\\n    }\\r\\n    \\r\\n    public static final class DrivetrainConstants {\\r\\n        public static final double DEADBAND = 0.1;\\r\\n        public static final double POWER_SCALING = 0.7;\\r\\n        // Controller deadbands and power scaling\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n---\\r\\n\\r\\n## Key Concepts Summary\\r\\n\\r\\n- **Subsystems** manage hardware directly and provide methods for controlling motors and sensors\\r\\n- **Commands** use subsystems to accomplish specific tasks and handle the timing of those tasks\\r\\n- **RobotContainer** connects user inputs to commands and manages the overall robot behavior\\r\\n- **Constants** store configuration values that can be easily modified without changing code logic\\r\\n\\r\\n## \ud83d\udcd6Learning Exercise\\r\\n\\r\\nNow that you understand the basic structure, try this hands-on exercise:\\r\\n\\r\\n### Modify Intake Speed\\r\\n\\r\\n**File:** `Constants.java` (Lines 15-16)\\r\\n\\r\\nChange the `INTAKE_SPEED` constant in `IntakeConstants` and observe the difference:\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Constants.java\\" {2} showLineNumbers=17\\r\\npublic static final class IntakeConstants {\\r\\n    public static final double INTAKE_SPEED = 0.5;  // Try changing to 0.3 or 0.7\\r\\n    public static final double SHOOT_SPEED = 0.8;\\r\\n    public static final double CORAL_DETECTION_DISTANCE = 5.0; // inches\\r\\n}\\r\\n```\\r\\n\\r\\n**What to try:**\\r\\n- Change `0.5` to `0.3` for slower intake\\r\\n- Change `0.5` to `0.7` for faster intake\\r\\n- Observe how this affects coral collection speed\\r\\n\\r\\n### Modify Shooter Speed\\r\\n\\r\\n**File:** `Constants.java` (Lines 15-16)\\r\\n\\r\\nChange the `SHOOT_SPEED` constant in `IntakeConstants` and observe the difference:\\r\\n\\r\\n```java title=\\"src\\\\main\\\\java\\\\frc\\\\robot\\\\Constants.java\\" {3} showLineNumbers=17\\r\\npublic static final class IntakeConstants {\\r\\n    public static final double INTAKE_SPEED = 0.5;  \\r\\n    public static final double SHOOT_SPEED = 0.8; // Try changing to 0.3 or 0.7\\r\\n    public static final double CORAL_DETECTION_DISTANCE = 5.0; // inches\\r\\n}\\r\\n```\\r\\n\\r\\n**What to try:**\\r\\n- Change `0.5` to `0.3` for slower shoot\\r\\n- Change `0.5` to `0.7` for faster shoot\\r\\n- Observe how this affects coral collection speed\\r\\n\\r\\nUnderstanding this structure will help you build more complex robot behaviors as we progress through the series."}]}}')}}]);